// SPDX-FileCopyrightText: 2023 SAP SE or an SAP affiliate company
// SPDX-License-Identifier: Apache-2.0

package handlers

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/gophercloud/gophercloud/v2"
	"github.com/sapcc/go-api-declarations/deployevent"

	"github.com/sapcc/tenso/internal/servicenow"
	"github.com/sapcc/tenso/internal/tenso"
)

//nolint:dupl
func init() {
	tenso.ValidationHandlerRegistry.Add(func() tenso.ValidationHandler { return &activeDirectoryDeploymentV1Validator{} })
	tenso.TranslationHandlerRegistry.Add(func() tenso.TranslationHandler { return &activeDirectoryDeploymentV1ToSNowTranslator{} })

	tenso.ValidationHandlerRegistry.Add(func() tenso.ValidationHandler { return &activeDirectoryDeploymentV2Validator{} })
	tenso.TranslationHandlerRegistry.Add(func() tenso.TranslationHandler { return &activeDirectoryDeploymentV2ToSNowTranslator{} })
	tenso.DeliveryHandlerRegistry.Add(func() tenso.DeliveryHandler { return &activeDirectoryDeploymentV1ToSNowDeliverer{} })
}

////////////////////////////////////////////////////////////////////////////////
// BEGIN v1 implementation
// TODO: Remove once pipeline has been migrated to v2 event format.
////////////////////////////////////////////////////////////////////////////////

// NOTE: This event is quite similar to the standard `deployevent.Event`, but
// since it is not generated by the standard process with our
// concourse-release-resource, it ends up looking sufficiently different to
// require different types throughout.
//
// TODO: Consider changing the AD deployment pipeline to use concourse-release-resource.
type activeDirectoryDeploymentV1Event struct {
	Region       string                   `json:"region"`
	RecordedAt   activeDirectoryEventTime `json:"recorded_at"`
	Landscape    string                   `json:"landscape"` // e.g. "dev" or "prod"
	Hostname     string                   `json:"host"`
	ADDeployment struct {
		Outcome   string                   `json:"outcome"`
		StartedAt activeDirectoryEventTime `json:"started_at"`
		// FinishedAt and DurationSeconds are not set for outcome "failed".
		FinishedAt      activeDirectoryEventTime `json:"finished_at"`
		DurationSeconds any                      `json:"duration,omitempty"`
	} `json:"ad_deployment"`
	GitRepos map[string]struct {
		Author        string `json:"author"`
		AuthoredAt    any    `json:"authored-at"` //NOTE: uses a different time format that I don't plan on dealing with right now
		Branch        string `json:"branch"`
		CommitID      string `json:"commit-id"`
		CommitMessage string `json:"commit-message"`
		RemoteURL     string `json:"remote-url"`
	} `json:"git"`
}

type activeDirectoryEventTime struct {
	Value *time.Time
}

func (a *activeDirectoryEventTime) UnmarshalJSON(buf []byte) error {
	var s string
	err := json.Unmarshal(buf, &s)
	if err != nil {
		return err
	}
	if s == "" {
		*a = activeDirectoryEventTime{nil}
		return nil
	}

	t, err := time.ParseInLocation("2006-01-02T15:04:05", s, time.UTC)
	*a = activeDirectoryEventTime{&t}
	return err
}

////////////////////////////////////////////////////////////////////////////////
// ValidationHandler

type activeDirectoryDeploymentV1Validator struct {
}

func (v *activeDirectoryDeploymentV1Validator) Init(context.Context, *gophercloud.ProviderClient, gophercloud.EndpointOpts) error {
	return nil
}

func (v *activeDirectoryDeploymentV1Validator) PluginTypeID() string {
	return "active-directory-deployment-from-concourse.v1"
}

func (v *activeDirectoryDeploymentV1Validator) ValidatePayload(payload []byte) (*tenso.PayloadInfo, error) {
	event, err := jsonUnmarshalStrict[activeDirectoryDeploymentV1Event](payload)
	if err != nil {
		return nil, err
	}

	if !regionRx.MatchString(event.Region) {
		return nil, fmt.Errorf(`value for field region is invalid: %q`, event.Region)
	}
	if event.RecordedAt.Value == nil {
		return nil, errors.New("value for field recorded_at is missing")
	}
	if event.Landscape == "" {
		//TODO: validate landscape value (we don't know the full range of possible values yet; at least "dev")
		return nil, errors.New("value for field landscape is missing")
	}
	if !strings.HasSuffix(event.Hostname, ".sap") {
		return nil, fmt.Errorf(`value for field host is invalid: %q`, event.Hostname)
	}

	for repoName, repoInfo := range event.GitRepos {
		if !gitCommitRx.MatchString(repoInfo.CommitID) {
			return nil, fmt.Errorf(`value for field git[%q].commit-id is invalid: %q`, repoName, repoInfo.CommitID)
		}
		if repoInfo.RemoteURL == "" {
			return nil, fmt.Errorf(`value for field git[%q].commit-id is invalid: %q`, repoName, repoInfo.CommitID)
		}
	}

	d := event.ADDeployment
	if d.StartedAt.Value == nil {
		return nil, errors.New("value for field ad_deployment.started_at is missing")
	}
	switch d.Outcome {
	case "succeeded":
		if d.FinishedAt.Value == nil {
			return nil, fmt.Errorf("field ad_deployment.finished_at must be set for outcome %q", d.Outcome)
		}
	case "failed":
		if d.FinishedAt.Value != nil {
			return nil, fmt.Errorf("field ad_deployment.finished_at may not be set for outcome %q", d.Outcome)
		}
	default:
		return nil, fmt.Errorf(`value for field ad_deployment.outcome is invalid: %q`, d.Outcome)
	}

	return &tenso.PayloadInfo{
		Description: "core/active-directory: deploy AD to " + event.Hostname,
	}, nil
}

////////////////////////////////////////////////////////////////////////////////
// TranslationHandler for SNow

type activeDirectoryDeploymentV1ToSNowTranslator struct {
	Mapping servicenow.MappingConfiguration
}

func (t *activeDirectoryDeploymentV1ToSNowTranslator) Init(context.Context, *gophercloud.ProviderClient, gophercloud.EndpointOpts) (err error) {
	t.Mapping, err = servicenow.LoadMappingConfiguration("TENSO_SERVICENOW_MAPPING_CONFIG_PATH")
	return err
}

func (t *activeDirectoryDeploymentV1ToSNowTranslator) PluginTypeID() string {
	return "active-directory-deployment-from-concourse.v1->active-directory-deployment-to-servicenow.v1"
}

func (t *activeDirectoryDeploymentV1ToSNowTranslator) TranslatePayload(payload []byte, routingInfo map[string]string) ([]byte, error) {
	event, err := jsonUnmarshalStrict[activeDirectoryDeploymentV1Event](payload)
	if err != nil {
		return nil, err
	}

	//NOTE: Some of this is implemented in a rather roundabout way since most of
	// our internal infrastructure revolves around deployevent types. As noted
	// above, I want to get this delivery path rebased on deployevent.Event
	// eventually.

	// get the semantically closest deployevent.Outcome value
	var outcome deployevent.Outcome
	switch event.ADDeployment.Outcome {
	case "succeeded":
		outcome = deployevent.OutcomeSucceeded
	case "failed":
		outcome = deployevent.OutcomeADDeploymentFailed
	default:
		err = fmt.Errorf(`value for field ad_deployment.outcome is invalid: %q`, event.ADDeployment.Outcome)
	}
	if err != nil {
		return nil, err
	}

	// get input descriptors by stuffing the GitRepos info in a mock deployevent.Event
	mock := deployevent.Event{
		GitRepos: make(map[string]deployevent.GitRepo),
	}
	for checkoutName, repoInfo := range event.GitRepos {
		mock.GitRepos[checkoutName] = deployevent.GitRepo{
			Branch:    repoInfo.Branch,
			CommitID:  repoInfo.CommitID,
			RemoteURL: repoInfo.RemoteURL,
		}
	}
	inputDesc := strings.Join(inputDescriptorsOf(mock), ", ")

	startedAt := *event.ADDeployment.StartedAt.Value
	recordedAt := *event.RecordedAt.Value
	chg := servicenow.Change{
		StartedAt:   &startedAt,
		EndedAt:     &recordedAt,
		Outcome:     outcome,
		Summary:     "Deploy AD to " + event.Hostname,
		Description: fmt.Sprintf("Deployed active-directory in landscape %s with versions: %s\n\nOutcome: %s", event.Landscape, inputDesc, event.ADDeployment.Outcome),
		Executee:    "",
		Region:      event.Region,
	}

	return chg.Serialize(t.Mapping, t.Mapping.ActiveDirectoryDeployment, routingInfo)
}

////////////////////////////////////////////////////////////////////////////////
// END v1 implementation (when removing v1 support, remove until here)
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// ValidationHandler

type activeDirectoryDeploymentV2Validator struct {
}

func (v *activeDirectoryDeploymentV2Validator) Init(context.Context, *gophercloud.ProviderClient, gophercloud.EndpointOpts) error {
	return nil
}

func (v *activeDirectoryDeploymentV2Validator) PluginTypeID() string {
	return "active-directory-deployment-from-concourse.v2"
}

func (v *activeDirectoryDeploymentV2Validator) ValidatePayload(payload []byte) (*tenso.PayloadInfo, error) {
	event, err := parseAndValidateDeployEvent(payload)
	if err != nil {
		return nil, err
	}

	if len(event.HelmReleases) != 0 {
		return nil, errors.New("helm-release[] may not be set for Active Directory deployment events")
	}
	if len(event.TerraformRuns) != 0 {
		return nil, errors.New("terraform-runs[] may not be set for Active Directory deployment events")
	}
	if event.ADDeployment == nil {
		return nil, errors.New("active-directory-deployment may not be empty")
	}

	ad := *event.ADDeployment
	missingField := func(field string) error {
		return fmt.Errorf("active-directory-deployment.%s may not be empty", field)
	}
	if ad.Landscape == "" {
		return nil, missingField("landscape")
	}
	if ad.Hostname == "" {
		return nil, missingField("hostname")
	}
	if !strings.HasSuffix(ad.Hostname, ".sap") {
		return nil, fmt.Errorf(`value for field active-directory-deployment.host is invalid: %q`, ad.Hostname)
	}
	if !ad.Outcome.IsKnownInputValue() {
		return nil, fmt.Errorf(`invalid value for field active-directory-deployment.outcome: %q`, ad.Outcome)
	}
	if ad.StartedAt == nil {
		return nil, missingField("started-at")
	}
	if ad.FinishedAt == nil && (ad.Outcome != deployevent.OutcomeNotDeployed && ad.Outcome != deployevent.OutcomeADDeploymentFailed) {
		return nil, fmt.Errorf(`field active-directory-deployment.finished-at must be set for outcome %q`, ad.Outcome)
	}
	if ad.FinishedAt != nil && (ad.Outcome == deployevent.OutcomeNotDeployed || ad.Outcome == deployevent.OutcomeADDeploymentFailed) {
		return nil, fmt.Errorf(`field active-directory-deployment.finished-at may not be set for outcome %q`, ad.Outcome)
	}

	return &tenso.PayloadInfo{
		Description: "core/active-directory: deploy AD to " + ad.Hostname,
	}, nil
}

////////////////////////////////////////////////////////////////////////////////
// TranslationHandler for SNow

type activeDirectoryDeploymentV2ToSNowTranslator struct {
	Mapping servicenow.MappingConfiguration
}

func (t *activeDirectoryDeploymentV2ToSNowTranslator) Init(context.Context, *gophercloud.ProviderClient, gophercloud.EndpointOpts) (err error) {
	t.Mapping, err = servicenow.LoadMappingConfiguration("TENSO_SERVICENOW_MAPPING_CONFIG_PATH")
	return err
}

func (t *activeDirectoryDeploymentV2ToSNowTranslator) PluginTypeID() string {
	return "active-directory-deployment-from-concourse.v2->active-directory-deployment-to-servicenow.v1"
}

func (t *activeDirectoryDeploymentV2ToSNowTranslator) TranslatePayload(payload []byte, routingInfo map[string]string) ([]byte, error) {
	event, err := jsonUnmarshalStrict[deployevent.Event](payload)
	if err != nil {
		return nil, err
	}

	chg := servicenow.Change{
		StartedAt: event.CombinedStartDate(),
		EndedAt:   event.RecordedAt,
		Outcome:   event.CombinedOutcome(),
		Summary:   "Deploy AD to " + event.ADDeployment.Hostname,
		Description: fmt.Sprintf("Deployed active-directory in landscape %s with versions: %s\n\nOutcome: %s",
			event.ADDeployment.Landscape,
			strings.Join(inputDescriptorsOf(event), ", "),
			event.ADDeployment.Outcome,
		),
		Executee: event.Pipeline.CreatedBy, //NOTE: can be empty
		Region:   event.Region,
	}

	return chg.Serialize(t.Mapping, t.Mapping.ActiveDirectoryDeployment, routingInfo)
}

////////////////////////////////////////////////////////////////////////////////
// DeliveryHandler for SNow

type activeDirectoryDeploymentV1ToSNowDeliverer struct {
	Mapping servicenow.MappingConfiguration
}

func (d *activeDirectoryDeploymentV1ToSNowDeliverer) Init(context.Context, *gophercloud.ProviderClient, gophercloud.EndpointOpts) (err error) {
	d.Mapping, err = servicenow.LoadMappingConfiguration("TENSO_SERVICENOW_MAPPING_CONFIG_PATH")
	return err
}

func (d *activeDirectoryDeploymentV1ToSNowDeliverer) PluginTypeID() string {
	return "active-directory-deployment-to-servicenow.v1"
}

func (d *activeDirectoryDeploymentV1ToSNowDeliverer) DeliverPayload(ctx context.Context, payload []byte, routingInfo map[string]string) (*tenso.DeliveryLog, error) {
	return d.Mapping.Endpoints.DeliverChangePayload(ctx, payload, routingInfo)
}
