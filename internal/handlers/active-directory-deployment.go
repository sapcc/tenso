/*******************************************************************************
*
* Copyright 2023 SAP SE
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You should have received a copy of the License along with this
* program. If not, you may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*******************************************************************************/

package handlers

import (
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/gophercloud/gophercloud"
	"github.com/sapcc/go-api-declarations/deployevent"

	"github.com/sapcc/tenso/internal/servicenow"
	"github.com/sapcc/tenso/internal/tenso"
)

func init() {
	tenso.ValidationHandlerRegistry.Add(func() tenso.ValidationHandler { return &activeDirectoryDeploymentValidator{} })
	tenso.TranslationHandlerRegistry.Add(func() tenso.TranslationHandler { return &activeDirectoryDeploymentToSNowTranslator{} })
	tenso.DeliveryHandlerRegistry.Add(func() tenso.DeliveryHandler { return &activeDirectoryDeploymentToSNowDeliverer{} })
}

// NOTE: This event is quite similar to the standard `deployevent.Event`, but
// since it is not generated by the standard process with our
// concourse-release-resource, it ends up looking sufficiently different to
// require different types throughout.
//
// TODO: Consider changing the AD deployment pipeline to use concourse-release-resource.
type activeDirectoryDeploymentEvent struct {
	Region       string                   `json:"region"`
	RecordedAt   activeDirectoryEventTime `json:"recorded_at"`
	Landscape    string                   `json:"landscape"` //e.g. "dev" or "prod"
	Hostname     string                   `json:"host"`
	ADDeployment struct {
		Outcome   string                   `json:"outcome"`
		StartedAt activeDirectoryEventTime `json:"started_at"`
		//FinishedAt and DurationSeconds are not set for outcome "failed".
		FinishedAt      activeDirectoryEventTime `json:"finished_at,omitempty"`
		DurationSeconds any                      `json:"duration,omitempty"`
	} `json:"ad_deployment"`
	GitRepos map[string]struct {
		Author        string `json:"author"`
		AuthoredAt    any    `json:"authored-at"` //NOTE: uses a different time format that I don't plan on dealing with right now
		Branch        string `json:"branch"`
		CommitID      string `json:"commit-id"`
		CommitMessage string `json:"commit-message"`
		RemoteURL     string `json:"remote-url"`
	} `json:"git"`
}

type activeDirectoryEventTime struct {
	Value *time.Time
}

func (a *activeDirectoryEventTime) UnmarshalJSON(buf []byte) error {
	var s string
	err := json.Unmarshal(buf, &s)
	if err != nil {
		return err
	}
	if s == "" {
		*a = activeDirectoryEventTime{nil}
		return nil
	}

	t, err := time.ParseInLocation("2006-01-02T15:04:05", s, time.UTC)
	*a = activeDirectoryEventTime{&t}
	return err
}

////////////////////////////////////////////////////////////////////////////////
// ValidationHandler

type activeDirectoryDeploymentValidator struct {
}

func (v *activeDirectoryDeploymentValidator) Init(*gophercloud.ProviderClient, gophercloud.EndpointOpts) error {
	return nil
}

func (v *activeDirectoryDeploymentValidator) PluginTypeID() string {
	return "active-directory-deployment-from-concourse.v1"
}

func (v *activeDirectoryDeploymentValidator) ValidatePayload(payload []byte) (*tenso.PayloadInfo, error) {
	event, err := jsonUnmarshalStrict[activeDirectoryDeploymentEvent](payload)
	if err != nil {
		return nil, err
	}

	if !regionRx.MatchString(event.Region) {
		return nil, fmt.Errorf(`value for field region is invalid: %q`, event.Region)
	}
	if event.RecordedAt.Value == nil {
		return nil, errors.New("value for field recorded_at is missing")
	}
	if event.Landscape == "" {
		//TODO: validate landscape value (we don't know the full range of possible values yet; at least "dev")
		return nil, errors.New("value for field landscape is missing")
	}
	if !strings.HasSuffix(event.Hostname, ".sap") {
		return nil, fmt.Errorf(`value for field host is invalid: %q`, event.Hostname)
	}

	for repoName, repoInfo := range event.GitRepos {
		if !gitCommitRx.MatchString(repoInfo.CommitID) {
			return nil, fmt.Errorf(`value for field git[%q].commit-id is invalid: %q`, repoName, repoInfo.CommitID)
		}
		if repoInfo.RemoteURL == "" {
			return nil, fmt.Errorf(`value for field git[%q].commit-id is invalid: %q`, repoName, repoInfo.CommitID)
		}
	}

	d := event.ADDeployment
	if d.StartedAt.Value == nil {
		return nil, errors.New("value for field ad_deployment.started_at is missing")
	}
	switch d.Outcome {
	case "succeeded":
		if d.FinishedAt.Value == nil {
			return nil, fmt.Errorf("field ad_deployment.finished_at must be set for outcome %q", d.Outcome)
		}
	case "failed":
		if d.FinishedAt.Value != nil {
			return nil, fmt.Errorf("field ad_deployment.finished_at may not be set for outcome %q", d.Outcome)
		}
	default:
		return nil, fmt.Errorf(`value for field ad_deployment.outcome is invalid: %q`, d.Outcome)
	}

	return &tenso.PayloadInfo{
		Description: fmt.Sprintf("core/active-directory: deploy AD to %s", event.Hostname),
	}, nil
}

////////////////////////////////////////////////////////////////////////////////
// TranslationHandler for SNow

type activeDirectoryDeploymentToSNowTranslator struct {
	Mapping servicenow.MappingConfiguration
}

func (t *activeDirectoryDeploymentToSNowTranslator) Init(*gophercloud.ProviderClient, gophercloud.EndpointOpts) (err error) {
	t.Mapping, err = servicenow.LoadMappingConfiguration()
	return err
}

func (t *activeDirectoryDeploymentToSNowTranslator) PluginTypeID() string {
	return "active-directory-deployment-from-concourse.v1->active-directory-deployment-to-servicenow.v1"
}

func (t *activeDirectoryDeploymentToSNowTranslator) TranslatePayload(payload []byte) ([]byte, error) {
	event, err := jsonUnmarshalStrict[activeDirectoryDeploymentEvent](payload)
	if err != nil {
		return nil, err
	}

	//NOTE: Some of this is implemented in a rather roundabout way since most of
	//our internal infrastructure revolves around deployevent types. As noted
	//above, I want to get this delivery path rebased on deployevent.Event
	//eventually.

	//get SNow close code by asking for the semantically closest deployevent.Outcome values
	var closeCode string
	switch event.ADDeployment.Outcome {
	case "succeeded":
		closeCode, err = servicenow.CloseCodeForOutcome(deployevent.OutcomeSucceeded)
	case "failed":
		closeCode, err = servicenow.CloseCodeForOutcome(deployevent.OutcomeHelmUpgradeFailed)
	default:
		err = fmt.Errorf(`value for field ad_deployment.outcome is invalid: %q`, event.ADDeployment.Outcome)
	}
	if err != nil {
		return nil, err
	}

	//get input descriptors by stuffing the GitRepos info in a mock deployevent.Event
	mock := deployevent.Event{
		GitRepos: make(map[string]deployevent.GitRepo),
	}
	for checkoutName, repoInfo := range event.GitRepos {
		mock.GitRepos[checkoutName] = deployevent.GitRepo{
			Branch:    repoInfo.Branch,
			CommitID:  repoInfo.CommitID,
			RemoteURL: repoInfo.RemoteURL,
		}
	}
	inputDesc := strings.Join(inputDescriptorsOf(mock), ", ")

	startedAt := *event.ADDeployment.StartedAt.Value
	recordedAt := *event.RecordedAt.Value
	chg := servicenow.Change{
		StartedAt:   &startedAt,
		EndedAt:     &recordedAt,
		CloseCode:   closeCode,
		Summary:     fmt.Sprintf("Deploy AD to %s", event.Hostname),
		Description: fmt.Sprintf("Deployed active-directory in landscape %s with versions: %s\n\nOutcome: %s", event.Landscape, inputDesc, event.ADDeployment.Outcome),
		Executee:    "",
		Region:      event.Region,
	}

	return chg.Serialize(t.Mapping, t.Mapping.ActiveDirectoryDeployment)
}

////////////////////////////////////////////////////////////////////////////////
// DeliveryHandler for SNow

type activeDirectoryDeploymentToSNowDeliverer struct {
	Client *servicenow.Client
}

func (d *activeDirectoryDeploymentToSNowDeliverer) Init(*gophercloud.ProviderClient, gophercloud.EndpointOpts) (err error) {
	d.Client, err = servicenow.NewClientFromEnv("TENSO_SERVICENOW")
	return err
}

func (d *activeDirectoryDeploymentToSNowDeliverer) PluginTypeID() string {
	return "active-directory-deployment-to-servicenow.v1"
}

func (d *activeDirectoryDeploymentToSNowDeliverer) DeliverPayload(payload []byte) (*tenso.DeliveryLog, error) {
	return d.Client.DeliverChangePayload(payload)
}
